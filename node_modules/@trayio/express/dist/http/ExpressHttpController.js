"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExpressHttpController = void 0;
const TE = __importStar(require("fp-ts/TaskEither"));
const E = __importStar(require("fp-ts/Either"));
const Http_1 = require("@trayio/commons/http/Http");
const BufferExtensions_1 = require("@trayio/commons/buffer/BufferExtensions");
const formidable_1 = __importDefault(require("formidable"));
const stream_1 = require("stream");
class ExpressHttpController {
    controller;
    baseTmpPathForUploadedFiles;
    logger;
    constructor(controller, baseTmpPathForUploadedFiles = '/tmp', logger) {
        this.controller = controller;
        this.baseTmpPathForUploadedFiles = baseTmpPathForUploadedFiles;
        this.logger = logger;
    }
    addRoute = (endpoint) => {
        const route = async (req, res) => {
            const headers = Object.entries(req.headers).reduce((acc, [key, value]) => {
                const newValue = typeof value === 'undefined' ? '' : value;
                return {
                    ...acc,
                    [key]: newValue,
                };
            }, {});
            const requestBody = await this.parseRequestBody(req);
            const httpResponse = await endpoint.execute(this.logger)({
                headers,
                pathParams: req.params,
                queryString: req.query,
                body: requestBody,
            })();
            const response = Object.entries(httpResponse.headers)
                .reduce((acc, [key, value]) => acc.setHeader(key, value), res)
                .status(httpResponse.statusCode);
            httpResponse.body.pipe(response);
        };
        let method;
        switch (endpoint.method) {
            case Http_1.HttpMethod.Get:
                method = 'get';
                break;
            case Http_1.HttpMethod.Post:
                method = 'post';
                break;
            case Http_1.HttpMethod.Put:
                method = 'put';
                break;
            case Http_1.HttpMethod.Delete:
                method = 'delete';
                break;
            case Http_1.HttpMethod.Patch:
                method = 'patch';
                break;
            default:
                method = 'get';
                break;
        }
        return (router) => router[method](endpoint.path, route);
    };
    addRoutes = (router) => {
        this.controller
            .getEndpoints()
            .forEach((endpoint) => this.addRoute(endpoint)(router));
        return router;
    };
    parseRequestBody = async (req) => {
        const contentType = req.headers['content-type'];
        if (contentType && contentType.startsWith('multipart/form-data')) {
            const multiPartResponse = await this.parseMultipartFormData(req)();
            const multiPartBody = E.getOrElse((error) => {
                throw new Error(error.message);
            })(multiPartResponse);
            return multiPartBody;
        }
        return this.parseGeneralRequestBody(req);
    };
    // express defaults empty request body to an empty object, so we need to transform to an array buffer
    parseGeneralRequestBody = (req) => {
        const body = Object.keys(req.body).length === 0 ? new ArrayBuffer(0) : req.body;
        return BufferExtensions_1.BufferExtensions.arrayBufferToReadable(body);
    };
    parseMultipartFormData = (req) => TE.tryCatch(() => new Promise((resolve, reject) => {
        /*
         * NOTE: inorder to use any other underlying file storage other than node fs, we would have to use
         * formidable's fileWriteStreamHandler option that enables formidable to write a file to a stream.
         * When used the fileWriteStreamHandler option with passThrough stream, we ran into errors that we didn't have
         * time to solve, but ideally, we would be using the FileStorage interface instead of letting formidable
         * write to the file system directly.
         */
        const form = (0, formidable_1.default)({
            maxFiles: 1,
            maxFileSize: 50 * 1024 * 1024,
            uploadDir: this.baseTmpPathForUploadedFiles,
        });
        form.parse(req, (err, fields, files) => {
            if (err) {
                reject(err);
            }
            else {
                const body = {
                    fields: this.flattenFields(fields),
                    files: this.flattenFiles(files),
                };
                resolve(body);
            }
        });
    }), (error) => new Error(error.message));
    flattenFields = (fields) => {
        const flattenedFields = {};
        Object.entries(fields).forEach(([key, value]) => {
            if (Array.isArray(value) && value.length > 1) {
                throw new Error(`Field ${key} has more than one value and is current not supported`);
            }
            if (Array.isArray(value)) {
                flattenedFields[key] = value.join(',');
            }
            else {
                flattenedFields[key] = value ?? '';
            }
        });
        return flattenedFields;
    };
    flattenFiles = (files) => {
        const flattenedFiles = {};
        Object.entries(files)
            .filter(([key, file]) => file !== null)
            .forEach(([key, file]) => {
            if (Array.isArray(file) && file.length > 1) {
                throw new Error(`Field ${key} has more than one file and is currently not supported`);
            }
            if (Array.isArray(file)) {
                const fileContent = this.convertFormidableFileToTrayFile(file[0]);
                flattenedFiles[key] = fileContent;
            }
        });
        return flattenedFiles;
    };
    convertFormidableFileToTrayFile = (file) => ({
        key: file.newFilename,
        metadata: {
            name: file.newFilename,
            contentType: file.mimetype ?? undefined,
            size: file.size,
        },
        content: stream_1.Readable.from('0'),
    });
}
exports.ExpressHttpController = ExpressHttpController;
