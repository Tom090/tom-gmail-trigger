"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AxiosHttpClient = void 0;
const Http_1 = require("@trayio/commons/http/Http");
const Task_1 = require("@trayio/commons/task/Task");
const axios_1 = __importDefault(require("axios"));
const FormData = require("form-data");
const NodeFsFileStorage_1 = require("@trayio/commons/file/NodeFsFileStorage");
const BufferExtensions_1 = require("@trayio/commons/buffer/BufferExtensions");
class AxiosHttpClient {
    fileStorage;
    constructor(fileStorage = new NodeFsFileStorage_1.NodeFsFileStorage()) {
        this.fileStorage = fileStorage;
    }
    execute(method, url, request) {
        /*
          Removes default headers so that we control what we send to the server, without this, it sends default content-type and accept headers,
          the caller of this HttpClient interface is responsible of deciding the values of these headers, axios shouldn't try to be smart
          and derive these from the body or even set defaults.
        */
        axios_1.default.defaults.headers.common = {};
        axios_1.default.defaults.headers.get = {};
        axios_1.default.defaults.headers.post = {};
        axios_1.default.defaults.headers.put = {};
        axios_1.default.defaults.headers.patch = {};
        axios_1.default.defaults.headers.delete = {};
        const finalUrl = Object.entries(request.pathParams).reduce((acc, [key, value]) => acc.replace(`:${key}`, encodeURIComponent(value)), url);
        const headers = Object.entries(request.headers).reduce((acc, [key, value]) => {
            const newValue = typeof value === 'string' ? value : value.join(', ');
            return {
                ...acc,
                [key.toLowerCase()]: newValue,
            };
        }, {});
        let axiosConfig;
        if (headers['content-type'] &&
            headers['content-type'].includes(Http_1.HttpContentType.MultipartRequestBody)) {
            const formData = new FormData();
            this.appendFields(formData)(request.body.fields);
            const { files } = request.body;
            Object.keys(files).forEach((key) => {
                const file = files[key];
                formData.append(key, file.content, {
                    filename: file.metadata.name ?? file.key,
                    contentType: file.metadata.contentType,
                });
            });
            axiosConfig = {
                url: finalUrl,
                method: method.toString(),
                data: formData,
                responseType: 'stream',
                headers,
                params: request.queryString,
            };
            return (0, Task_1.createTaskEitherFromPromiseWithSimpleError)(() => (0, axios_1.default)(axiosConfig)
                .then(this.axiosResponseToHttpResponse)
                .catch(this.axiosErrorToHttpResponse.bind(this)));
        }
        axiosConfig = {
            url: finalUrl,
            method: method.toString(),
            data: request.body,
            responseType: 'stream',
            headers,
            params: request.queryString,
        };
        return (0, Task_1.createTaskEitherFromPromiseWithSimpleError)(() => (0, axios_1.default)(axiosConfig)
            .then(this.axiosResponseToHttpResponse)
            .catch(this.axiosErrorToHttpResponse.bind(this)));
    }
    axiosErrorToHttpResponse(axiosError) {
        if (axiosError.response !== undefined) {
            return this.axiosResponseToHttpResponse(axiosError.response);
        }
        return {
            headers: {},
            statusCode: 500,
            body: BufferExtensions_1.BufferExtensions.arrayBufferToReadable(new ArrayBuffer(0)),
        };
    }
    axiosResponseToHttpResponse(axiosResponse) {
        return {
            headers: axiosResponse.headers,
            statusCode: axiosResponse.status,
            body: axiosResponse.data,
        };
    }
    appendFields = (formData) => (fields) => {
        Object.entries(fields).forEach(([key, value]) => {
            formData.append(key, value);
        });
        return formData;
    };
}
exports.AxiosHttpClient = AxiosHttpClient;
