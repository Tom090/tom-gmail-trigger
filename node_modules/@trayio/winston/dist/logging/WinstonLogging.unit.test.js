"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const winston_1 = require("winston");
const WinstonLogging_1 = require("./WinstonLogging");
jest.mock('winston', () => ({
    ...jest.requireActual('winston'),
    createLogger: jest.fn(),
    Logger: jest.fn(),
}));
describe('Logger', () => {
    const mockedCreateLogger = winston_1.createLogger;
    beforeEach(() => {
        jest.clearAllMocks();
    });
    describe.each([
        { logLevel: 'info', winstonLogLevel: 'info' },
        { logLevel: 'error', winstonLogLevel: 'error' },
        { logLevel: 'warning', winstonLogLevel: 'warn' },
        { logLevel: 'debug', winstonLogLevel: 'debug' },
    ])('log level %s', ({ logLevel, winstonLogLevel }) => {
        describe('When provided with a message and observability context', () => {
            const mockInfo = jest.fn();
            const mockWinston = {
                [winstonLogLevel]: mockInfo,
            };
            beforeEach(() => {
                mockedCreateLogger.mockImplementation(() => mockWinston);
                const logger = (0, WinstonLogging_1.getLogger)();
                logger[logLevel]('test log message', {
                    host: 'localhost',
                });
            });
            it('should instantiate the logger with console and json formatting', () => {
                expect(winston_1.createLogger).toHaveBeenCalledWith({
                    format: winston_1.format.json(),
                    exitOnError: false,
                    transports: [expect.any(winston_1.transports.Console)],
                });
            });
            it('Should log the message and context', () => {
                expect(mockInfo).toHaveBeenCalledWith('test log message', {
                    host: 'localhost',
                    service: 'tray-typescript-sdk',
                });
            });
        });
    });
    describe('when logging a message', () => {
        describe('when no context is provided', () => {
            const mockInfo = jest.fn();
            const mockWinston = {
                info: mockInfo,
            };
            beforeEach(() => {
                mockedCreateLogger.mockImplementation(() => mockWinston);
                const logger = (0, WinstonLogging_1.getLogger)({ env: 'test' });
                logger.info('test log message', {});
            });
            it('should log the default context of service name and env', () => {
                expect(mockInfo).toHaveBeenCalledWith('test log message', {
                    service: 'tray-typescript-sdk',
                    env: 'test',
                });
            });
        });
        describe('when an initial context is provided', () => {
            const mockInfo = jest.fn();
            const mockWinston = {
                info: mockInfo,
            };
            beforeEach(() => {
                mockedCreateLogger.mockImplementation(() => mockWinston);
                const logger = (0, WinstonLogging_1.getLogger)({ env: 'test' });
                logger.info('test log message', {});
                logger.info('test log message two', {});
            });
            it('should log the inital context with every subsequent log', () => {
                expect(mockInfo).toHaveBeenNthCalledWith(1, 'test log message', {
                    service: 'tray-typescript-sdk',
                    env: 'test',
                });
                expect(mockInfo).toHaveBeenNthCalledWith(2, 'test log message two', {
                    service: 'tray-typescript-sdk',
                    env: 'test',
                });
            });
        });
    });
});
