"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.httpClientTest = void 0;
const E = __importStar(require("fp-ts/Either"));
const stream_1 = require("stream");
const function_1 = require("fp-ts/function");
const t = __importStar(require("io-ts"));
const http_1 = require("http");
const util_1 = require("util");
const TE = __importStar(require("fp-ts/TaskEither"));
const formidable_1 = __importDefault(require("formidable"));
const Task_1 = require("../task/Task");
const JsonSerialization_1 = require("../serialization/JsonSerialization");
const TypeCodec_1 = require("../codec/TypeCodec");
const Http_1 = require("./Http");
const File_1 = require("../file/File");
const NodeFsFileStorage_1 = require("../file/NodeFsFileStorage");
const BufferExtensions_1 = require("../buffer/BufferExtensions");
function httpClientTest(httpClient) {
    const serialization = new JsonSerialization_1.JsonSerialization();
    const fileStorage = new NodeFsFileStorage_1.NodeFsFileStorage();
    const testErrorResponseCodec = TypeCodec_1.TypeCodec.fromDescriptor(t.type({
        message: t.string,
    }));
    const testResponseCodec = TypeCodec_1.TypeCodec.fromDescriptor(t.type({
        strField: t.string,
        intField: t.number,
    }));
    const ReadableCodec = new t.Type('Readable', (input) => input instanceof stream_1.Readable, (input, ctx) => input instanceof stream_1.Readable ? t.success(input) : t.failure(input, ctx), (input) => input);
    const testMultiPartBodyTypeCodec = TypeCodec_1.TypeCodec.fromDescriptor(t.type({
        fields: t.record(t.string, t.string),
        files: t.record(t.string, t.type({
            key: t.string,
            metadata: File_1.fileMetadataDescriptor,
            content: t.any,
        })),
    }));
    const testInputCodec = TypeCodec_1.TypeCodec.fromDescriptor(t.type({
        inputField: t.number,
    }));
    function sendHttpResponse(httpResponse, response, responseCodec) {
        const serializedResponse = (0, function_1.pipe)(E.right(responseCodec.encode(response)), E.map((encodedResponse) => serialization.serialize(encodedResponse)), E.getOrElse(() => (new util_1.TextEncoder().encode('Error serializing value').buffer)));
        httpResponse.end(Buffer.from(serializedResponse));
    }
    async function processHttpRequest(requestCodec, responseCodec, httpRequest, httpResponse, process, isMultiPartBody = false) {
        if (isMultiPartBody) {
            const form = (0, formidable_1.default)({});
            let fields;
            let files;
            try {
                [fields, files] = await form.parse(httpRequest);
            }
            catch (err) {
                console.error(err);
                return;
            }
            const input = {
                fields: flattenFields(fields),
                files: flattenFiles(files),
            };
            const response = (0, function_1.pipe)(requestCodec.decode(input), E.map(process), E.map((result) => new util_1.TextEncoder().encode(JSON.stringify(responseCodec.encode(result))).buffer), E.getOrElse(() => new util_1.TextEncoder().encode('Error serializing value').buffer));
            httpResponse.end(Buffer.from(response));
        }
        const body = [];
        httpRequest.on('data', (chunk) => {
            body.push(chunk);
        });
        httpRequest.on('end', () => {
            const buffer = Buffer.concat(body);
            const response = (0, function_1.pipe)(serialization.deserialize(buffer), E.chain((encodedRequest) => requestCodec.decode(encodedRequest)), E.map(process), E.map((result) => responseCodec.encode(result)), E.map((encodedResult) => serialization.serialize(encodedResult)), E.getOrElse(() => (new util_1.TextEncoder().encode('Error serializing value').buffer)));
            httpResponse.end(Buffer.from(response));
        });
    }
    const flattenFields = (fields) => {
        const flattenedFields = {};
        Object.entries(fields).forEach(([key, value]) => {
            if (Array.isArray(value) && value.length > 1) {
                throw new Error(`Field ${key} has more than one value and is current not supported`);
            }
            if (Array.isArray(value)) {
                flattenedFields[key] = value.join(',');
            }
            else {
                flattenedFields[key] = value ?? '';
            }
        });
        return flattenedFields;
    };
    const flattenFiles = (files) => {
        const flattenedFiles = {};
        Object.entries(files)
            .filter(([_key, file]) => file !== null)
            .forEach(([key, file]) => {
            if (Array.isArray(file) && file.length > 1) {
                throw new Error(`Field ${key} has more than one file and is currently not supported`);
            }
            if (Array.isArray(file)) {
                const fileContent = convertFormidableFileToTrayFile(file[0]);
                flattenedFiles[key] = fileContent;
            }
        });
        return flattenedFiles;
    };
    const convertFormidableFileToTrayFile = (file) => ({
        key: file.newFilename,
        metadata: {
            name: file.originalFilename ?? '',
            size: file.size,
        },
        content: stream_1.Readable.from(file.filepath),
    });
    const requestListener = async (req, res) => {
        if (req.method === 'GET' && typeof req.headers['error'] === 'string') {
            const errorCode = +req.headers['error'];
            res.writeHead(errorCode, {
                [Http_1.HttpHeader.ContentType]: Http_1.HttpContentType.Json,
            });
            const errorResponse = {
                message: `some error message ${errorCode}`,
            };
            sendHttpResponse(res, errorResponse, testErrorResponseCodec);
        }
        else if (req.method === 'GET') {
            const customHeader = req.headers['x-custom-header'];
            res.writeHead(200, { [Http_1.HttpHeader.ContentType]: Http_1.HttpContentType.Json });
            const response = {
                strField: customHeader,
                intField: 123,
            };
            sendHttpResponse(res, response, testResponseCodec);
        }
        else if (req.method === 'POST' &&
            req.headers['content-type']?.includes(Http_1.HttpContentType.MultipartRequestBody)) {
            res.writeHead(200, { [Http_1.HttpHeader.ContentType]: Http_1.HttpContentType.Json });
            await processHttpRequest(testMultiPartBodyTypeCodec, testMultiPartBodyTypeCodec, req, res, (input) => input, true);
        }
        else {
            const customHeader = req.headers['x-custom-header'];
            res.writeHead(200, { [Http_1.HttpHeader.ContentType]: Http_1.HttpContentType.Json });
            await processHttpRequest(testInputCodec, testResponseCodec, req, res, (input) => ({
                strField: customHeader,
                intField: input.inputField,
            }));
        }
    };
    const host = 'localhost';
    const port = 8000; // TODO: Get random port
    const baseUrl = `http://${host}:${port}`;
    const server = (0, http_1.createServer)(requestListener);
    describe('HttpClient Test', () => {
        beforeAll(async () => {
            await new Promise((resolve) => {
                server.listen(port, host, resolve);
            });
        });
        afterAll(async () => {
            await new Promise((resolve, reject) => {
                server.close((error) => {
                    if (error) {
                        reject(error);
                    }
                    else {
                        resolve();
                    }
                });
            });
        });
        test('should send a GET request', async () => {
            const response = await httpClient.execute(Http_1.HttpMethod.Get, baseUrl, {
                headers: { 'x-custom-header': 'customVal' },
                pathParams: {},
                queryString: {},
                body: BufferExtensions_1.BufferExtensions.arrayBufferToReadable(new ArrayBuffer(0)),
            })();
            const testValue = {
                strField: 'customVal',
                intField: 123,
            };
            const result = (0, function_1.pipe)(response, TE.fromEither, TE.chain((httpResponse) => BufferExtensions_1.BufferExtensions.readableToArrayBuffer(httpResponse.body)), TE.match((error) => E.left(error), (buffer) => (0, function_1.pipe)(serialization.deserialize(buffer), E.chain((encoded) => testResponseCodec.decode(encoded)))));
            const resultE = await result();
            expect(resultE).toStrictEqual(E.right(testValue));
        });
        test('should send a POST request', async () => {
            const testInput = {
                inputField: 321,
            };
            const response = await (0, function_1.pipe)((0, Task_1.createTaskEitherFromEither)(E.right(testInputCodec.encode(testInput))), TE.map((encoded) => serialization.serialize(encoded)), TE.chain((serializedInput) => httpClient.execute(Http_1.HttpMethod.Post, baseUrl, {
                headers: {
                    'x-custom-header': 'customVal',
                },
                pathParams: {},
                queryString: {},
                body: BufferExtensions_1.BufferExtensions.arrayBufferToReadable(serializedInput),
            })))();
            const testValue = {
                strField: 'customVal',
                intField: 321,
            };
            const result = (0, function_1.pipe)(response, TE.fromEither, TE.chain((httpResponse) => BufferExtensions_1.BufferExtensions.readableToArrayBuffer(httpResponse.body)), TE.match((error) => E.left(error), (buffer) => (0, function_1.pipe)(serialization.deserialize(buffer), E.chain((encoded) => testResponseCodec.decode(encoded)))));
            const resultE = await result();
            expect(resultE).toStrictEqual(E.right(testValue));
        });
        test('should send a POST request with multipart body', async () => {
            await fileStorage.delete('file1')();
            await fileStorage.delete('file2')();
            const file1 = await fileStorage.write({
                key: 'file1',
                metadata: {
                    name: 'file1',
                },
                content: stream_1.Readable.from('file 1 content'),
            })();
            const file2 = await fileStorage.write({
                key: 'file2',
                metadata: {
                    name: 'file2',
                },
                content: stream_1.Readable.from('file 2 content'),
            })();
            if (file1._tag === 'Left') {
                throw file1.left;
            }
            if (file2._tag === 'Left') {
                throw file2.left;
            }
            const testInput = {
                fields: {
                    field1: 'field1',
                    field2: 'field2',
                },
                files: {
                    file1: {
                        key: 'file1',
                        metadata: {
                            name: 'file1',
                        },
                        content: stream_1.Readable.from('Hello world'),
                    },
                    file2: {
                        key: 'file2',
                        metadata: {
                            name: 'file2',
                        },
                        content: stream_1.Readable.from('Hello world'),
                    },
                },
            };
            const response = await httpClient.execute(Http_1.HttpMethod.Post, baseUrl, {
                headers: {
                    'x-custom-header': 'customVal',
                    'content-type': Http_1.HttpContentType.MultipartRequestBody,
                },
                pathParams: {},
                queryString: {},
                body: testInput,
            })();
            const result = (0, function_1.pipe)(response, TE.fromEither, TE.chain((httpResponse) => BufferExtensions_1.BufferExtensions.readableToArrayBuffer(httpResponse.body)), TE.match((error) => E.left(error), (buffer) => (0, function_1.pipe)(serialization.deserialize(buffer), E.chain((encoded) => testMultiPartBodyTypeCodec.decode(encoded)))));
            const resultE = await result();
            expect(resultE).toEqual(E.right(expect.objectContaining({
                fields: testInput.fields,
                files: expect.objectContaining({
                    file1: expect.objectContaining({
                        key: expect.any(String),
                        metadata: expect.objectContaining({
                            name: 'file1',
                        }),
                    }),
                    file2: expect.objectContaining({
                        key: expect.any(String),
                        metadata: expect.objectContaining({
                            name: 'file2',
                        }),
                    }),
                }),
            })));
        });
        test('should parse an internal error response', async () => {
            const response = await httpClient.execute(Http_1.HttpMethod.Get, baseUrl, {
                headers: { error: '500' },
                pathParams: {},
                queryString: {},
                body: BufferExtensions_1.BufferExtensions.arrayBufferToReadable(new ArrayBuffer(0)),
            })();
            const testErrorResponse = {
                message: 'some error message 500',
            };
            if (E.isLeft(response)) {
                throw response.left;
            }
            const responseBodyE = await BufferExtensions_1.BufferExtensions.readableToArrayBuffer(response.right.body)();
            expect(response.right.statusCode).toStrictEqual(500);
            expect(responseBodyE).toStrictEqual(E.right(serialization.serialize(testErrorResponseCodec.encode(testErrorResponse))));
        });
        test('should parse a not found error response', async () => {
            const response = await httpClient.execute(Http_1.HttpMethod.Get, baseUrl, {
                headers: { error: '404' },
                pathParams: {},
                queryString: {},
                body: BufferExtensions_1.BufferExtensions.arrayBufferToReadable(new ArrayBuffer(0)),
            })();
            const testErrorResponse = {
                message: 'some error message 404',
            };
            if (E.isLeft(response)) {
                throw response.left;
            }
            const responseBodyE = await BufferExtensions_1.BufferExtensions.readableToArrayBuffer(response.right.body)();
            expect(response.right.statusCode).toStrictEqual(404);
            expect(responseBodyE).toStrictEqual(E.right(serialization.serialize(testErrorResponseCodec.encode(testErrorResponse))));
        });
    });
}
exports.httpClientTest = httpClientTest;
