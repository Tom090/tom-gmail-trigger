import * as TE from 'fp-ts/TaskEither';
import * as E from 'fp-ts/Either';
import * as t from 'io-ts';
import { Codec } from '../codec/Codec';
export type DynamicType = string | number | boolean | null | DynamicObject | DynamicArray;
export type DynamicObject = {
    [x: string]: DynamicType;
};
export type DynamicArray = Array<DynamicType>;
export interface DynamicObjectInterface {
    fromBase64String: (base64Str: string) => E.Either<Error, DynamicObject>;
    removeNullValues: (value: DynamicObject) => DynamicObject;
}
export declare const DynamicObject: DynamicObjectInterface;
export interface DynamicTypeInterface {
    readFromFile: (path: string) => E.Either<Error, DynamicType>;
    writeToFile: (path: string, value: DynamicType) => E.Either<Error, undefined>;
    writeToFileAsync: (path: string, value: DynamicType) => TE.TaskEither<Error, undefined>;
    safeCast: <T>(dynamicType: DynamicType, codec: Codec<T>) => E.Either<Error, T>;
}
export declare const DynamicType: DynamicTypeInterface;
export declare const dynamicTypeDescriptor: t.Type<DynamicType>;
export declare const dynamicObjectTypeDescriptor: t.Type<DynamicObject>;
export declare const dynamicArrayTypeDescriptor: t.Type<DynamicArray>;
//# sourceMappingURL=DynamicType.d.ts.map