"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OperationExecutionTest = void 0;
const WinstonCliLogging_1 = require("@trayio/winston/cli/WinstonCliLogging");
const CliLogging_1 = require("@trayio/commons/cli/CliLogging");
// TODO move this to commons, newer versions of jest removed the "fail" method but left it in the types package.
function fail(reason) {
    throw new Error(reason);
}
global.fail = fail;
class OperationExecutionTest {
    handlerTest;
    handlerInvocationFactory;
    constructor(handlerTest, handlerInvocationFactory) {
        this.handlerTest = handlerTest;
        this.handlerInvocationFactory = handlerInvocationFactory;
    }
    test(execution) {
        describe(`Operation ${this.handlerTest.handlerReference.name} Test`, () => {
            const defaultCtx = this.handlerTest.ctx;
            const defaultInvoke = this.handlerInvocationFactory(defaultCtx);
            let testContext;
            beforeAll(async () => {
                const beforeAllResult = await this.handlerTest.beforeAllFunction(defaultCtx, defaultInvoke);
                switch (beforeAllResult.isSuccess) {
                    case false:
                        fail(`BeforeAll has failed with the following error ${beforeAllResult.error}`);
                    case true:
                        testContext = beforeAllResult.value;
                }
            });
            this.handlerTest.testCaseFactories.forEach((testCaseFactory) => {
                it(testCaseFactory.description, async () => {
                    const testCase = testCaseFactory.testCase(testContext);
                    const { ctx } = testCase;
                    const invoke = this.handlerInvocationFactory(ctx);
                    const givenResult = await testCase.givenFunction(ctx, testContext, invoke);
                    let testCaseContext;
                    switch (givenResult.isSuccess) {
                        case false:
                            fail(`Given has failed with the following error ${givenResult.error}`);
                        case true:
                            testCaseContext = givenResult.value;
                    }
                    const input = testCase.whenFunction(ctx, testContext, testCaseContext);
                    const output = await execution.execute(ctx, input);
                    const infoArg = process.argv.filter((arg) => arg.startsWith('--verbose'))[0];
                    if (infoArg === '--verbose=true') {
                        const logger = new WinstonCliLogging_1.WinstonCliLogging();
                        logger.logBlock('Operation input', CliLogging_1.CliColors.blue);
                        logger.log(input);
                        if (!output.isFailure) {
                            const logOutput = output;
                            logger.logBlock('Operation output', CliLogging_1.CliColors.blue);
                            logger.log(logOutput.value);
                        }
                    }
                    const testCaseResult = {
                        ctx,
                        testContext,
                        testCaseContext,
                        input,
                        output,
                    };
                    testCase.thenFunction(testCaseResult);
                    const finallyResult = await testCase.finallyFunction(testCaseResult, invoke);
                    if (finallyResult.isFailure) {
                        fail(`Finally has failed with the following error ${finallyResult.error}`);
                    }
                });
            });
            afterAll(async () => {
                const afterAllResult = await this.handlerTest.afterAllFunction(defaultCtx, testContext, defaultInvoke);
                if (afterAllResult.isFailure) {
                    fail(`AfterAll has failed with the following error ${afterAllResult.error}`);
                }
            });
        });
    }
}
exports.OperationExecutionTest = OperationExecutionTest;
