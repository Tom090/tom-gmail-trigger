"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OperationHandlerTestSetup = exports.OperationHandlerTestRegistry = exports.OperationHandlerTestAuthConfiguration = exports.OperationHandlerTestBeforeAllConfiguration = exports.OperationHandlerTestMandatoryTestCaseConfiguration = exports.OperationHandlerTestAfterAllConfiguration = exports.OperationHandlerTest = exports.OperationHandlerTestCaseFactory = exports.OperationHandlerTestCaseAuthConfiguration = exports.OperationHandlerTestCaseGivenConfiguration = exports.OperationHandlerTestCaseWhenConfiguration = exports.OperationHandlerTestCaseThenConfiguration = exports.OperationHandlerTestCaseFinallyConfiguration = exports.OperationHandlerTestCase = void 0;
const O = __importStar(require("fp-ts/Option"));
const function_1 = require("fp-ts/function");
const DynamicType_1 = require("@trayio/commons/dynamictype/DynamicType");
const CallSite_1 = require("@trayio/commons/callsite/CallSite");
const pathLib = __importStar(require("path"));
const OperationHandler_1 = require("./OperationHandler");
const readContextJsonFile = (ctxName) => {
    const operationDescriptorOpt = (0, function_1.pipe)(O.fromNullable(CallSite_1.CallSite.getCurrentCallSites()[1]), // skip the last caller because it is a function within this file
    O.map((caller) => pathLib.normalize(pathLib.join(caller.folderPath, '..', `${ctxName}.ctx.json`))), O.chain((operationDescriptorPath) => O.fromEither(DynamicType_1.DynamicType.readFromFile(operationDescriptorPath))));
    // If this error is thrown, there is a problem with the file or there is a problem with the runtime not supporting callsites
    const operationDescriptor = O.getOrElse(() => {
        throw new Error(`Runtime error: Cannot read ${ctxName}.ctx.json file`);
    })(operationDescriptorOpt);
    return operationDescriptor;
};
class OperationHandlerTestCase {
    description;
    ctx;
    testContext;
    givenFunction;
    whenFunction;
    thenFunction;
    finallyFunction;
    constructor(description, ctx, testContext, givenFunction, whenFunction, thenFunction, finallyFunction) {
        this.description = description;
        this.ctx = ctx;
        this.testContext = testContext;
        this.givenFunction = givenFunction;
        this.whenFunction = whenFunction;
        this.thenFunction = thenFunction;
        this.finallyFunction = finallyFunction;
    }
}
exports.OperationHandlerTestCase = OperationHandlerTestCase;
class OperationHandlerTestCaseFinallyConfiguration {
    description;
    ctx;
    testContext;
    givenFunction;
    whenFunction;
    thenFunction;
    constructor(description, ctx, testContext, givenFunction, whenFunction, thenFunction) {
        this.description = description;
        this.ctx = ctx;
        this.testContext = testContext;
        this.givenFunction = givenFunction;
        this.whenFunction = whenFunction;
        this.thenFunction = thenFunction;
    }
    finally(finallyFunction) {
        return new OperationHandlerTestCase(this.description, this.ctx, this.testContext, this.givenFunction, this.whenFunction, this.thenFunction, finallyFunction);
    }
    finallyDoNothing() {
        return this.finally(() => Promise.resolve(OperationHandler_1.OperationHandlerResult.success(undefined)));
    }
}
exports.OperationHandlerTestCaseFinallyConfiguration = OperationHandlerTestCaseFinallyConfiguration;
class OperationHandlerTestCaseThenConfiguration {
    description;
    ctx;
    testContext;
    givenFunction;
    whenFunction;
    constructor(description, ctx, testContext, givenFunction, whenFunction) {
        this.description = description;
        this.ctx = ctx;
        this.testContext = testContext;
        this.givenFunction = givenFunction;
        this.whenFunction = whenFunction;
    }
    then(thenFunction) {
        return new OperationHandlerTestCaseFinallyConfiguration(this.description, this.ctx, this.testContext, this.givenFunction, this.whenFunction, thenFunction);
    }
}
exports.OperationHandlerTestCaseThenConfiguration = OperationHandlerTestCaseThenConfiguration;
class OperationHandlerTestCaseWhenConfiguration {
    description;
    ctx;
    testContext;
    givenFunction;
    constructor(description, ctx, testContext, givenFunction) {
        this.description = description;
        this.ctx = ctx;
        this.testContext = testContext;
        this.givenFunction = givenFunction;
    }
    when(whenFunction) {
        return new OperationHandlerTestCaseThenConfiguration(this.description, this.ctx, this.testContext, this.givenFunction, whenFunction);
    }
}
exports.OperationHandlerTestCaseWhenConfiguration = OperationHandlerTestCaseWhenConfiguration;
class OperationHandlerTestCaseGivenConfiguration {
    description;
    ctx;
    testContext;
    constructor(description, ctx, testContext) {
        this.description = description;
        this.ctx = ctx;
        this.testContext = testContext;
    }
    given(givenFunction) {
        return new OperationHandlerTestCaseWhenConfiguration(this.description, this.ctx, this.testContext, givenFunction);
    }
    givenNothing() {
        return this.given(() => Promise.resolve(OperationHandler_1.OperationHandlerResult.success({})));
    }
}
exports.OperationHandlerTestCaseGivenConfiguration = OperationHandlerTestCaseGivenConfiguration;
class OperationHandlerTestCaseAuthConfiguration {
    description;
    defaultCtx;
    testContext;
    constructor(description, defaultCtx, testContext) {
        this.description = description;
        this.defaultCtx = defaultCtx;
        this.testContext = testContext;
    }
    usingHandlerContext(ctxName) {
        return new OperationHandlerTestCaseGivenConfiguration(this.description, readContextJsonFile(ctxName), this.testContext);
    }
    given(givenFunction) {
        return new OperationHandlerTestCaseWhenConfiguration(this.description, this.defaultCtx, this.testContext, givenFunction);
    }
    givenNothing() {
        return this.given(() => Promise.resolve(OperationHandler_1.OperationHandlerResult.success({})));
    }
}
exports.OperationHandlerTestCaseAuthConfiguration = OperationHandlerTestCaseAuthConfiguration;
class OperationHandlerTestCaseFactory {
    description;
    ctx;
    testCaseSetup;
    constructor(description, ctx, testCaseSetup) {
        this.description = description;
        this.ctx = ctx;
        this.testCaseSetup = testCaseSetup;
    }
    testCase(testContext) {
        return this.testCaseSetup(new OperationHandlerTestCaseAuthConfiguration(this.description, this.ctx, testContext));
    }
}
exports.OperationHandlerTestCaseFactory = OperationHandlerTestCaseFactory;
class OperationHandlerTest {
    handlerReference;
    ctx;
    beforeAllFunction;
    testCaseFactories;
    afterAllFunction;
    constructor(handlerReference, ctx, beforeAllFunction, testCaseFactories, afterAllFunction) {
        this.handlerReference = handlerReference;
        this.ctx = ctx;
        this.beforeAllFunction = beforeAllFunction;
        this.testCaseFactories = testCaseFactories;
        this.afterAllFunction = afterAllFunction;
    }
}
exports.OperationHandlerTest = OperationHandlerTest;
class OperationHandlerTestAfterAllConfiguration {
    handlerReference;
    ctx;
    beforeAllFunction;
    testCaseFactories;
    constructor(handlerReference, ctx, beforeAllFunction, testCaseFactories) {
        this.handlerReference = handlerReference;
        this.ctx = ctx;
        this.beforeAllFunction = beforeAllFunction;
        this.testCaseFactories = testCaseFactories;
    }
    testCase(description, testCaseSetup) {
        const testCaseFactory = new OperationHandlerTestCaseFactory(description, this.ctx, testCaseSetup);
        return new OperationHandlerTestAfterAllConfiguration(this.handlerReference, this.ctx, this.beforeAllFunction, this.testCaseFactories.concat([testCaseFactory]));
    }
    afterAll(afterAllFunction) {
        return new OperationHandlerTest(this.handlerReference, this.ctx, this.beforeAllFunction, this.testCaseFactories, afterAllFunction);
    }
    nothingAfterAll() {
        return this.afterAll(() => Promise.resolve(OperationHandler_1.OperationHandlerResult.success(undefined)));
    }
}
exports.OperationHandlerTestAfterAllConfiguration = OperationHandlerTestAfterAllConfiguration;
class OperationHandlerTestMandatoryTestCaseConfiguration {
    handlerReference;
    ctx;
    beforeAllFunction;
    constructor(handlerReference, ctx, beforeAllFunction) {
        this.handlerReference = handlerReference;
        this.ctx = ctx;
        this.beforeAllFunction = beforeAllFunction;
    }
    testCase(description, testCaseSetup) {
        const testCaseFactory = new OperationHandlerTestCaseFactory(description, this.ctx, testCaseSetup);
        return new OperationHandlerTestAfterAllConfiguration(this.handlerReference, this.ctx, this.beforeAllFunction, [testCaseFactory]);
    }
}
exports.OperationHandlerTestMandatoryTestCaseConfiguration = OperationHandlerTestMandatoryTestCaseConfiguration;
class OperationHandlerTestBeforeAllConfiguration {
    handlerReference;
    ctx;
    constructor(handlerReference, ctx) {
        this.handlerReference = handlerReference;
        this.ctx = ctx;
    }
    beforeAll(beforeAllFunction) {
        return new OperationHandlerTestMandatoryTestCaseConfiguration(this.handlerReference, this.ctx, beforeAllFunction);
    }
    nothingBeforeAll() {
        return this.beforeAll(() => Promise.resolve(OperationHandler_1.OperationHandlerResult.success({})));
    }
}
exports.OperationHandlerTestBeforeAllConfiguration = OperationHandlerTestBeforeAllConfiguration;
class OperationHandlerTestAuthConfiguration {
    handlerReference;
    constructor(handlerReference) {
        this.handlerReference = handlerReference;
    }
    usingHandlerContext(ctxName) {
        return new OperationHandlerTestBeforeAllConfiguration(this.handlerReference, readContextJsonFile(ctxName));
    }
}
exports.OperationHandlerTestAuthConfiguration = OperationHandlerTestAuthConfiguration;
class OperationHandlerTestRegistry {
    static instance = new OperationHandlerTestRegistry();
    static register(handlerTest) {
        OperationHandlerTestRegistry.instance.register(handlerTest);
    }
    static resolve(reference) {
        return OperationHandlerTestRegistry.instance.resolve(reference);
    }
    static onRegistration(onRegistrationFunction) {
        OperationHandlerTestRegistry.instance.onRegistration(onRegistrationFunction);
    }
    registry;
    observers;
    constructor() {
        this.registry = new Map();
        this.observers = [];
    }
    register(handlerTest) {
        const { handlerReference } = handlerTest;
        this.registry.set(handlerReference.name, handlerTest);
        this.observers.forEach((observer) => observer(handlerReference));
    }
    resolve(reference) {
        const handlerTest = this.registry.get(reference.name);
        if (!handlerTest) {
            return O.none;
        }
        return O.some(handlerTest);
    }
    onRegistration(onRegistrationFunction) {
        this.observers.push(onRegistrationFunction);
    }
}
exports.OperationHandlerTestRegistry = OperationHandlerTestRegistry;
exports.OperationHandlerTestSetup = {
    configureHandlerTest: (handlerReference, handlerTestSetup) => {
        const handlerTest = handlerTestSetup(new OperationHandlerTestAuthConfiguration(handlerReference));
        OperationHandlerTestRegistry.register(handlerTest);
    },
};
