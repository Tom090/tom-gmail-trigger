import { HttpContentType, HttpMethod, HttpRequest, HttpHeaderValue, HttpResponse, HttpHeaders } from '@trayio/commons/http/Http';
import { DynamicObject, DynamicType } from '@trayio/commons/dynamictype/DynamicType';
import * as O from 'fp-ts/Option';
import { OperationHandlerAuth, OperationHandlerContext, OperationHandlerResult, FileReference } from './OperationHandler';
export type HttpOperationMultipartBody = {
    fields: Record<string, string>;
    files: Record<string, FileReference>;
};
export type HttpOperationBody = FileReference | string | DynamicType | HttpOperationMultipartBody | undefined;
export declare class HttpOperationRequestBuilder {
    readonly path: string;
    private readonly method;
    private readonly request;
    constructor(method: HttpMethod, path: string, request: HttpRequest);
    withBodyAsJson<T extends DynamicType>(body: T): HttpOperationRequest;
    withBodyAsText(body: string): HttpOperationRequest;
    withBodyAsFormUrlEncoded<T extends DynamicObject>(body: T): HttpOperationRequest;
    withBodyAsMultipart(body: HttpOperationMultipartBody): HttpOperationRequest;
    withBodyAsFile(file: FileReference): HttpOperationRequest;
    withoutBody(): HttpOperationRequest;
    addPathParameter(name: string, value: string): HttpOperationRequestBuilder;
    addQueryString(name: string, value: string | string[]): HttpOperationRequestBuilder;
    withMethod(method: HttpMethod): HttpOperationRequestBuilder;
    withUrl(url: string): HttpOperationRequestBuilder;
    withBearerToken(token: string): HttpOperationRequestBuilder;
    addHeader(name: string, value: HttpHeaderValue): HttpOperationRequestBuilder;
}
export declare class HttpOperationRequest {
    readonly path: string;
    readonly method: HttpMethod;
    readonly request: HttpRequest;
    readonly contentType: O.Option<HttpContentType>;
    readonly body: HttpOperationBody;
    constructor(path: string, method: HttpMethod, request: HttpRequest, contentType: O.Option<HttpContentType>, body: HttpOperationBody);
}
export type HttpOperationRequestHandler<AUTH extends OperationHandlerAuth<unknown, unknown>, IN> = (ctx: OperationHandlerContext<AUTH>, input: IN, request: HttpOperationRequestBuilder) => HttpOperationRequest;
export type HttpOperationResponseParser<BODY, OUT> = (body: BODY) => OperationHandlerResult<OUT>;
export declare class HttpOperationResponseBuilder<ERROR, OUT> {
    private response;
    private errorHandling;
    private errorContentType;
    constructor(response: HttpResponse, errorHandling: HttpOperationResponseParser<ERROR, OUT>, errorContentType: O.Option<HttpContentType>);
    getStatusCode(): number;
    getHeader(name: string): HttpHeaderValue | undefined;
    getHeaders(): HttpHeaders;
    withErrorHandling(errorHandling: HttpOperationResponseParser<undefined, OUT>): HttpOperationResponseBuilder<undefined, OUT>;
    withJsonErrorHandling<T extends DynamicType>(errorHandling: HttpOperationResponseParser<T, OUT>): HttpOperationResponseBuilder<T, OUT>;
    parseWithoutBody(responseParser: HttpOperationResponseParser<undefined, OUT>): HttpOperationResponse<OUT>;
    parseWithBodyAsText(responseParser: HttpOperationResponseParser<string, OUT>): HttpOperationResponse<OUT>;
    parseWithBodyAsJson<T extends DynamicType>(responseParser?: HttpOperationResponseParser<T, OUT>): HttpOperationResponse<OUT>;
    parseWithBodyAsFile<FileReference>(responseParser: HttpOperationResponseParser<FileReference, OUT>): HttpOperationResponse<OUT>;
}
export declare class HttpOperationResponse<OUT> {
    readonly response: HttpResponse;
    readonly errorHandling: HttpOperationResponseParser<any, OUT>;
    readonly contentType: O.Option<HttpContentType>;
    readonly responseParser: HttpOperationResponseParser<any, OUT>;
    readonly errorContentType: O.Option<HttpContentType>;
    constructor(response: HttpResponse, errorHandling: HttpOperationResponseParser<any, OUT>, errorContentType: O.Option<HttpContentType>, contentType: O.Option<HttpContentType>, responseParser: HttpOperationResponseParser<any, OUT>);
}
export type HttpOperationResponseHandler<AUTH extends OperationHandlerAuth<unknown, unknown>, IN, OUT> = (ctx: OperationHandlerContext<AUTH>, input: IN, response: HttpOperationResponseBuilder<any, OUT>) => HttpOperationResponse<OUT>;
export declare class HttpOperationHandler<AUTH extends OperationHandlerAuth<unknown, unknown>, IN, OUT> {
    readonly _tag: 'HttpOperationHandler';
    readonly request: HttpOperationRequestBuilder;
    readonly requestHandler: HttpOperationRequestHandler<AUTH, IN>;
    readonly responseHandler: HttpOperationResponseHandler<AUTH, IN, OUT>;
    constructor(request: HttpOperationRequestBuilder, requestHandler: HttpOperationRequestHandler<AUTH, IN>, responseHandler: HttpOperationResponseHandler<AUTH, IN, OUT>);
}
export declare class HttpOperationHandlerResponseConfiguration<AUTH extends OperationHandlerAuth<unknown, unknown>, IN, OUT> {
    private request;
    private requestHandler;
    constructor(request: HttpOperationRequestBuilder, requestHandler: HttpOperationRequestHandler<AUTH, IN>);
    handleResponse(responseHandler: HttpOperationResponseHandler<AUTH, IN, OUT>): HttpOperationHandler<AUTH, IN, OUT>;
}
export declare class HttpOperationHandlerRequestConfiguration<AUTH extends OperationHandlerAuth<unknown, unknown>, IN, OUT> {
    private request;
    constructor(request: HttpOperationRequestBuilder);
    handleRequest(requestHandler: HttpOperationRequestHandler<AUTH, IN>): HttpOperationHandlerResponseConfiguration<AUTH, IN, OUT>;
}
export declare class HttpOperationHandlerConfiguration<AUTH extends OperationHandlerAuth<unknown, unknown>, IN, OUT> {
    get(path: string): HttpOperationHandlerRequestConfiguration<AUTH, IN, OUT>;
    post(path: string): HttpOperationHandlerRequestConfiguration<AUTH, IN, OUT>;
    put(path: string): HttpOperationHandlerRequestConfiguration<AUTH, IN, OUT>;
    patch(path: string): HttpOperationHandlerRequestConfiguration<AUTH, IN, OUT>;
    delete(path: string): HttpOperationHandlerRequestConfiguration<AUTH, IN, OUT>;
    private initialRequest;
}
export type HttpOperationHandlerSetup<AUTH extends OperationHandlerAuth<unknown, unknown>, IN, OUT> = (http: HttpOperationHandlerConfiguration<AUTH, IN, OUT>) => HttpOperationHandler<AUTH, IN, OUT>;
//# sourceMappingURL=HttpOperationHandler.d.ts.map